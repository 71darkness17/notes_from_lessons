#useful #theory #c
## L-value и R-value
	l-value - объект в памяти, на который можно ссылаться и изменять. Может быть слева от знака присваивания.
	r-value - временное значение, не связанное с фиксированным местом в памяти.
## Инкременты
Инкременты можно применять только к l-value, так как r-value, не имеет обозначенного места в памяти и не может быть изменен
#### Префиксная запись
В случае префиксной записи сначала производиться действие инкремента, а после возвращение значения l-value.
```c
	int b = 2;
	int b1 = ++b; //b1 = 3, b = 3
```
#### Постфиксная запись
В случае постфиксной записи сначала производиться возврат значения l-value, а после действие инкремента
```c
	int a = 2;
	int a1 = a++; //a1 = 2, a = 3
```
## Указатели
#### Определение
Переменная которая в значении хранит адрес памяти
Может хранить адрес:\
	- Переменной
	- Функции
	- Массива
	- Объекта
	- Другого указателя
#### Объявление указателя
```c
	int y = 0;
	int *yPtr = 0;
	yPtr = &y;
	//yPtr
```
`*xPtr` - разыменование
`&x` - получение ссылки
#### Двойной указатель(указатель на указатель)
###### Определение: 
	указатель содержащий ссылку на другой указатель
###### Объявление
```c
	int y = 0;
	int *p = &y;
	int **pp = &p;
```
#### Указатели и массивы
Указатель на массив это имя массива
```c
	int b[5];
	int *p = b;
	int *p1 = &b[0]
	//p1 == p => *p1 == *p
```
Указатель на массив содержит ссылку на его первый элемент, а все `+1` указатели содержат следующие элементы массива
Имя массива - указатель, но константа, а значит не может быть использована в качестве l-value и использовать инкременты. В это же время переменные указатели могут быть l-value и использовать инкременты.
```c
int arr[5];
int *p = arr;
arr++ //так нельзя
p++ //так можно(и нужно)
```
#### Арифметика указателей
Указатель - обычное целое число => можно прибавлять и убавлять целые числа и другие указатели
```c
	Возможные действия:
	
	<указатель> = <указатель> + <целое число>
	
	<указатель> = <указатель> – <целое число>
	
	<указатель> = <указатель> ++
	
	<указатель> = <указатель> –-
	
	<целое число> = <указатель> - <указатель>
```
==Требуется только для обращения к элементам массива через указатель на его первый элемент==
#### Массивы указателей
Можно создавать массив указателей который может содержать указатели на первые элементы массивов
```c
	char* MyArr[5] {"East","West","North","South"};
	printf("%c",*(MyArr[2]+2)); // 'r'
```
#### Указатель на массив
Такие указатели ссылаются на весь массив, а не на его первый элемент
При арифметике смещаются сразу на весь размер массива
## Динамические массивы
#### Определение
- Имеет неопределенное количество элементов
- Память под них выделяется только по запросу пользователя
- Работают медленнее статических массивов
#### Функции для работы с памятью динамический массивов
```c
//Выделение памяти размера size
void * malloc (size_t size);
//Выделение блока для хранения n-элементов по size байт
void * calloc(size_t n, size_t size);
//Перераспределение блока памяти
void * realloc(void* ptr, size_t size);
//Освобождение блока памяти
void free(void *ptr);
```
#### Выделение памяти
```c
char * MyArr = 0;

int n = 0;

puts("Enter a number");

scanf("%d", &n);

//выделение памяти под массив символьного типа

MyArr =(char *) calloc(n, sizeof(char) );

…

//освобождение памяти из-под массива

free(MyArr);
```

#### Выделение памяти для двумерного массива
```c
int ** MyArr = 0, n, m;
puts("Enter two numbers");
scanf("%d%d", &n, &m);
//выделение памяти под двумерный массив

//сначала под массив указателей
MyArr = (int **) calloc(n, sizeof(int *) );

//потом под каждый из подмассивов
for (int i=0; i<n; i++) {
	MyArr[i] = (int *) calloc(m, sizeof(int));
}
//освобождение памяти
//сначала из-под каждого подмассива

for (int i=0; i<n; i++)
free(MyArr[i]);

//потом из-под массива указателей
free(MyArr);
```


## Функции
### Критерии хорошей функции
- Выполняет поставленную задачу
- Сжато хранит данные
- Лишний раз не обращается
### Типовые названия
- `compute` - что-то вычислить
- `initialize` - где создается объект
- `find` - найти
- `is_.......` - всегда boolean

