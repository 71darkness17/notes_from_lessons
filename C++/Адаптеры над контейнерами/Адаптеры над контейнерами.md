_Адаптеры_ над стандартными контейнерами — это не самостоятельные контейнеры. Они используют какой-нибудь другой контейнер (например, дек или вектор) для хранения своих элементов, но при этом предоставляют свой набор функций для работы с ними. В стандартной библиотеке есть адаптеры `std::stack`, `std::queue` и `std::priority_queue`.

- Стек (`stack`)
    
    [Стек](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) — это последовательность элементов, в которую разрешается добавлять и извлекать элементы только с одной стороны. Обращение к промежуточным элементам не допускается. Говорят, что структура данных «стек» реализует идею ==**LIFO (last in — first out)**==.
    
    Понятно, что эти действия можно сделать с помощью вектора или дека и операций `push_back` и `pop_back`. Адаптер `[std::stack](https://en.cppreference.com/w/cpp/container/stack)` является обёрткой над такими контейнерами с особым интерфейсом — функциями `push`, `pop` и `top`. Это позволяет более выразительно подчеркнуть, что используется не просто какой-то контейнер, а именно стек как структура данных.
    
    ![[Untitled 4.png|Untitled 4.png]]
    
    ```C++
    \#include <iostream>
    \#include <stack>
     
    int main() {
        std::stack<int> s;
        s.push(1);
        s.push(13);
        s.pop();  // удалить элемент с вершины стека (в стеке останется 1)
     
        std::cout << s.top() << "\n";  // получить элемент на вершине стека, не удаляя его
     
        if (s.empty()) {  // проверка на пустоту
           std::cout << "Stack is empty\n";
        }
    }
    ```
    
    Функция `pop` ничего не возвращает. Напротив, функция `top` возвращает элемент, но никак не меняет состояние стека. По умолчанию стек использует контейнер `std::deque` для хранения элементов. При желании мы можем указать другой тип этого контейнера. Всё, что требуется от этого контейнера, — это поддержка операций `push_back`, `pop_back`, `back` и `empty`:  
      
      
    
    ```C++
    \#include <iostream>
    \#include <list>
    \#include <stack>
     
    int main() {
        std::stack<int, std::list<int>> s;  // используем std::list для хранения элементов в стеке
        // ...
    }
    ```
    
- Очередь (`queue`)
    
    Очередь реализует идею [FIFO](https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)) (first in — first out). Можно считать, что элементы встают в очередь с одного конца, а извлекаются с другого. Очередь предоставляет функции `push`, `pop`, `front` и `back`.
    
    ![[Untitled 1 2.png|Untitled 1 2.png]]
    
    ```C++
    \#include <iostream>
    \#include <queue>
     
    int main() {
        std::queue<int> s;
        s.push(1);
        s.push(13);
     
        std::cout << s.front() << "\n";  // 1
        std::cout << s.back() << "\n";  // 13
     
        s.pop();  // в очереди останется 13
     
        if (s.empty()) {
           std::cout << "Queue is empty\n";
        }
    }
    ```
    
    Так же как и в `std::stack`, в очереди по умолчанию используется `std::deque` для хранения элементов. Этот контейнер точно так же можно заменить. Для этого нужно указать тип нового контейнера во втором шаблонном параметре. Однако в отличие от стека здесь не получится использовать `std::vector`, так как у него нет функций `push_front` и `pop_front`.
    
- Очередь с приоритетами (`priority_queue`)
    
    Рассмотрим адаптер `[std::priority_queue](https://en.cppreference.com/w/cpp/container/priority_queue)` — [очередь с приоритетами](https://en.wikipedia.org/wiki/Priority_queue). Эта структура данных позволяет за ==логарифмическое время== добавлять и удалять элементы и за ==константное время== получать максимальный элемент. Типичная реализация очереди с приоритетами основана на структуре данных [«куча»](https://en.wikipedia.org/wiki/Heap_(data_structure)). Для хранения элементов используется контейнер с индексами и с возможностью добавления в конец. На эту роль подходят `std::vector` и `std::deque`, но не подходит `std::list`. По умолчанию используется `std::vector`.
    
    ![[Untitled 2 2.png|Untitled 2 2.png]]
    
    ```C++
    \#include <iostream>
    \#include <queue>  // именно queue, а не priority_queue
     
    int main() {
        std::priority_queue<int> pq;
        for (int x : {3, 14, 15, 92, 6, 0, 1, 10}) {
            pq.push(x);
        }
        while (!pq.empty()) {
            std::cout << pq.top() << "\n";
            pq.pop();
        }
        // Будет напечатано 92, 15, 14, 10, 6, 3, 1, 0
    }
    ```
    
    - Примечание
        
        Для сравнения элементов по умолчанию используется оператор `<`. Чтобы воспользоваться оператором `>` и, соответственно, извлекать из очереди минимальные элементы вместо максимальных, можно передать в третьем шаблонном параметре специальную обёртку `std::greater<int>`.
        
        ```C++
        \#include <iostream>
        \#include <functional>
        \#include <queue>
        \#include <vector>
         
        int main() {
            std::priority_queue<
                int,
                std::vector<int>,  // тип внутреннего контейнера; его приходится указывать, если нам нужен третий параметр
                std::greater<int>  // вспомогательная обёртка над оператором > (а не <)
            > pq;
         
            for (int x : {3, 14, 15, 92, 6}) {
                pq.push(x);
            }
         
            while (!pq.empty()) {
                std::cout << pq.top() << "\n";
                pq.pop();
            }
            // Будет напечатано 3 6 14 15 92
        }
        ```