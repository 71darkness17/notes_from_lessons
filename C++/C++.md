- ==База==
    - Первая программа
        
        ```C++
        \#include <iostream>
         
        int main() {
            std::cout << "Hello, world!\n";
        }
        ```
        
        Простейшая программа. **Директива** `\#include <iostream>` подключает стандартный библиотечный заголовочный файл для работы с потоками ввода-вывода (input-output streams). Для печати мы используем поток вывода `std::cout`, где `cout` расшифровывается как character output, то есть «символьный вывод».  
          
          
        
    - Область видимости
        
        Область видимости (scope) - та часть кода и те объекты, к которым программа в данный момент имеет доступ. Пример:
        
        ```C++
        \#include <iostream>
         
        int a = 1;  // глобальная переменная
         
        int main() {
            int b = 2;  // локальная переменная
            {
                int c = 3;  // локальная переменная внутри блока
                std::cout << a << " " << b << " " << c << "\n";  // корректно
            }
         
            // Эта строчка не скомпилируется,
            // так как переменная c не определена в данной области:
            std::cout << c << "\n";
        }
        ```
        
        В этом примере есть три области:
        
        - глобальная, в которой определена переменная `a`;
        - тело функции `main`, в которой определена переменная `b`;
        - внутренний блок, в котором определена переменная `c`.
        
        В последней строке примера переменная `c` недоступна, так как её область видимости уже закончилась. В случае коллизии имён компилятор всегда выбирает самую вложенную область видимости.
        
    - Типы данных
        - Простые типы данных
            
            ```C++
            int main() {
                char c = '1';    // символ
                bool b = true;   // логическая переменная, принимает значения false и true
                int i = 42;      // целое число (занимает, как правило, 4 байта)
                short int si = 17;           // короткое целое (занимает 2 байта)
                long li = 12321321312;       // длинное целое (как правило, 8 байт)
                long long lli = 12321321312; // длинное целое (как правило, 8 байт)
                float f = 2.71828;           // дробное число с плавающей запятой (4 байта)
                double d = 3.141592;         // дробное число двойной точности (8 байт)
                long double ld = 1e15;       // длинное дробное (как правило, 16 байт)
            }
            ```
            
        - Размер этих типов (зависит от компилятора, битности и ОС)
            
            ```C++
            int main() {
                std::cout << "char: " << sizeof(char) << "\n";                 //  1
                std::cout << "bool: " << sizeof(bool) << "\n";                 //  1
                std::cout << "short int: " << sizeof(short int) << "\n";       //  2 (по стандарту >= 2)
                std::cout << "int: " << sizeof(int) << "\n";                   //  4 (по стандарту >= 2)
                std::cout << "long int: " << sizeof(long int) << "\n";         //  8 (по стандарту >= 4)
                std::cout << "long long int: " << sizeof(long long) << "\n";   //  8 (по стандарту >= 8)
                std::cout << "float: " << sizeof(float) << "\n";               //  4
                std::cout << "double: " << sizeof(double) << "\n";             //  8
                std::cout << "long double: " << sizeof(long double) << "\n";   // 16
            }
            ```
            
        - Автоматический вывод типа
            
            Компилятор C++ умеет автоматически выводить тип переменной по значению, которое ей присваивается. Для этого вместо типа надо написать ключевое слово `auto`:  
              
            
            ```C++
            int main() {
                auto x = 42;  // int
                auto pi = 3.14159;  // double
            }
            ```
            
        - ==Переполнение целочисленных типов==
            
            Стандартные числовые типы имеют ограниченный размер и ограниченное множество допустимых значений. При арифметических операциях над числами таких типов может возникнуть переполнение — ситуация, когда результат операции не помещается в тип:  
              
            
            ```C++
            \#include <iostream>
             
            int main() {
                unsigned int a = 123456;  // на 64-битной платформе sizeof(a) == 4
             
                // Произведение a * a не помещается в 4 байта, так как оно больше 2^32
                std::cout << a * a << "\n";
            }
            ```
            
            В этом примере выражение `a * a` будет иметь тот же тип, что и аргументы. То, что на самом деле будет вычислено, зависит от знаковости типа.
            
            Беззнаковые типы можно спокойно переполнять: вычисления будут производиться по модулю соответствующей степени двойки. Другими словами, будут учтены только младшие биты результата:  
              
            
            ```C++
            int main() {
                unsigned int x = 0;      // на 64-битной платформе sizeof(x) == 4
                unsigned int y = x - 1;  // 4294967295, то есть 2**32 - 1
                unsigned int z = y + 1;  // 0
            }
            ```
            
    - Ветвления и циклы
        
        И - `&&`  
        ИЛИ -  
        `||`  
        НЕ -  
        `!`
        
        - условный оператор if-else
            
            ```C++
            if (condition1) {
                // случай, когда condition1 истинно
            } else if (condition2) {
                // случай, когда condition1 ложно, а condition2 истинно
            } else if (condition3) {
                // случай, когда condition1 и condition2 ложны, а condition3 истинно
            } else {
                // случай, когда condition1, condition2 и condition3 ложны
            }
            ```
            
        - условный оператор switch
            
            Выражения внутри скобок оператора `switch` и в блоках `case` должны быть простого целочисленного или символьного типа. В приведённой выше программе значение `+` относится к типу `char`. Использование сложных типов (например, строк) приведёт к ошибке компиляции:
            
            ```C++
            \#include <cstdint>
            \#include <iostream>
             // Калькулятор
            int main() {
                int64_t a, b;
                char operation;
                std::cin >> a >> operation >> b;
             
                int64_t result;
                switch (operation) {
                    case '+':
                        result = a + b;
                        break;  // если не написать этот break, программа просто пойдёт дальше в код следующего блока case
                    case '-':
                        result = a - b;
                        break;
                    case '*':
                        result = a * b;
                        break;
                    case '/':
                    case ':':
                        result = a / b;
                        break;
                    case '%':
                        result = a % b;
                        break;
                    default:  // здесь обрабатывается случай, когда ни один case не сработал.
                        result = 0;
                }
             
                std::cout << result << "\n";
            }
            ```
            
        - цикл for
            
            Цикл `for` — самый гибкий.
            
            ```C++
            \#include <iostream>
             
            int main() {
                for (int i = 1; i <= 10; ++i) {
                    std::cout << i << "\t" << i * i << "\n";
                }
            }
            ```
            
        - цикл while / do-while
            
            Это цикл с постусловием. Отличие от цикла `while` заключается в том, что первая итерация всегда выполняется безусловно. Только после её завершения проверяется условие цикла. Если оно истинно, то цикл продолжается.
            
            ```C++
            \#include <iostream>
             
            int main() {
                int n = 1;
                do {
                    std::cout << n << "\t" << n * n << "\n";
                    ++n;
                } while (n <= 10);
            }
            ```
            
            Без особых причин пользоваться этим видом циклов не стоит, старайтесь использовать циклы `while` или `for`.
            
        - цикл range-based for / for each
            
            Этот цикл применим к контейнерам разной природы (массивам, векторам, спискам и т. д.), с которыми мы познакомимся позже. Пока рассмотрим его на примере строк. Цикл позволяет удобно проитерироваться по символам строки, не используя индексов. В этом примере мы считываем строку и печатаем отдельно все символы строки и их ASCII-коды:  
              
            
            ```C++
            \#include <iostream>
            \#include <string>
             
            int main() {
                std::string line;
                std::getline(std::cin, line);
                for (char symbol : line) {
                    std::cout << symbol << "\t" << static_cast<int>(symbol) << "\n";
                }
            }
            ```
            
              
            
        
        Оператор `break` досрочно заканчивает текущий цикл. Оператор `continue` прыгает в самый конец тела цикла и, если условие цикла позволяет, переходит на следующую итерацию.
        
    - Функции
        - Основа
            
            Функции позволяют отделить часто используемый код и переиспользовать его с разными значениями аргументов.
            
            ```C++
            int Sum(int a, int b) {  // в заголовке функции указывается тип возвращаемого значения и типы аргументов
                return a + b;
            }
            // Если функция ничего не должна возвращать, её можно объявить как void:
            void DoSomething(double d, char c) {
                // ...
                // писать return в конце такой функции не обязательно,
                //     но если требуется завершить функцию, можно написать просто return;
            }
             
            int main() {
                int x = 17, y = 42;
                int z = Sum(x, y);
                DoSomething(3.14, '@');
            }
            ```
            
        - ==Преобразование типов(static_cast)==
            
            Чтобы деление производилось с остатком, нужно одну из переменных привести ц вещественному типу, с этим поможет оператор `static_cast`
            
            ```C++
            \#include <iostream>
            
            
            int main() {
            	int x = 5,
            		y = 3;
            	std::cout << x / y << '\n'; // 1
            	std::cout << static_cast<double>(x) / y; // 1.66667
            }
            ```
            
        - Считывание строки(getline)
            
            ```C++
            \#include <iostream>
            \#include <string>
             
            int main() {
                std::string name;
                std::getline(std::cin, name);
                std::cout << "Hello, " << name << "!\n";
            }
            ```
            
            Здесь мы использовали функцию `getline` из заголовочного файла `string`, которая считывает всю строку при вводе, а не строку до первого пробела, как делает функция `cin`
            
        - Рекурсия
            
            Вот пример рекурсивной функции, вычисляющей факториал:
            
            ```C++
            \#include <iostream>
            
            unsigned long long Factorial(unsigned long long n) {
                if (n == 0) {
                    return 1;
                }
                return n * Factorial(n - 1);  // рекурсивный вызов
            }
            
            int main() {
                std::cout << Factorial(5) << "\n";  // 120
            }
            ```
            
            Помните, что если делать очень много рекурсивных вызовов, то рано или поздно переполнится ==стек== — область памяти, в которой хранятся аргументы и локальные переменные текущей функции.
            
        - Изменение объектов, подаваемых на вход (ссылками)
            
            Можем ли мы изменить переданный аргумент внутри функции, чтобы это повлияло на аргументы в месте вызова? Да, для этого надо передать аргументы через ссылку или указатель. Вот классический пример функции, меняющей два аргумента местами:
            
            ```C++
            void Swap(int& x, int& y) {  // передаём аргументы по ссылке
                int z = x;
                x = y;
                y = z;
            }
             
            int main() {
                int a = 1, b = 2;
                Swap(a, b);
                std::cout << a << " " << b << "\n";  // 2 1
            }
            ```
            
            Аргументы сложных типов (векторы, строки, любые контейнеры, большие структуры) всегда лучше передавать в функцию по константной ссылке, если функция использует их только для чтения. Из этого правила бывают исключения, но о них мы поговорим отдельно.
            
            ```C++
            void f(const std::vector<int>& v) {
                // Такой аргумент не требует дорогого копирования,
                // его нельзя случайно изменить внутри,
                // и такую функцию можно вызывать от констант!
            } // Если нужно изменить вектор, убираем const
            ```
            
        - Возвращаемые значения функций
            
            В отличие от аргументов, значения сложных типов можно без проблем возвращать из функций. Здесь от ненужного копирования (по крайней мере, для стандартных контейнеров) спасает [copy elision](https://en.cppreference.com/w/cpp/language/copy_elision).
            
            ```C++
            \#include <iostream>
            \#include <string>
            \#include <vector>
             
            std::string Concatenate(const std::vector<std::string>& parts) {
                std::string result;
                for (const auto& part : parts) {
                    result += part;
                }
                return result;
            }
             
            int main() {
                std::vector<std::string> parts = {"abra", "ca", "dabra"};
                std::cout << Concatenate(parts) << "\n";  // abracadabra
            }
            ```
            
        - Лямбда-функции
            
            Иногда бывает неудобно определять отдельную именованную функцию для сравнения. Тогда можно определить анонимную [лямбда-функцию](https://en.cppreference.com/w/cpp/language/lambda) прямо в месте её использования.
            
            - Синтаксис
                
                Лямбда функция состоит из трёх блоков:
                
                - Квадратные скобки(`[]`) - Контекст. В них мы можем передать переменные, которые объявлены вне лямбда-функции через запятую, и они будут доступны в самой лямбда-функции.
                - Круглые скобки(`()`) - Аргументы функции.
                - Фигурные скобки(`{}`) - Тело функции.
                
                ```C++
                int main() {[](){}();} // Пример пустой лямбда-функции
                ```
                
                - Разбор
                    
                    ```C++
                    int main()  // Функция main без аргументов.
                    {
                        []    // Объявление лямбда-функции без списка захвата...
                        ()    // ... с пустым списком аргументов ...
                        {}    // ... и пустым телом, ...
                        ();   // ... которая тут же вызывается.
                    }
                    ```
                    
            - Пример
                
                ```C++
                \#include <algorithm>
                \#include <vector>
                 
                struct Date {
                    int year, month, day;
                };
                 
                int main() {
                    std::vector<Date> dates;
                    std::sort(dates.begin(), dates.end(), [](const Date& lhs, const Date& rhs) {
                        return std::tie(lhs.month, lhs.day) < std::tie(rhs.month, rhs.day);
                    });
                }
                ```
                
                Тип возвращаемого значения тут не указывается, компилятор умеет его угадывать по `return` (его можно указать после круглых скобок на «питоновский» манер через `->`, но не обязательно).
                
- Операторы
    - Унарные
        
        “Uno” - один. Работают с одним значением (операндом)
        
        - Инкремент / декремент (`++` / `--`)
            
            Инкремент: `++`
            
            Декремент: `--`
            
            Увеличивает и уменьшает число на 1, сдвигает итератор влево / вправо. Существуют префиксные(`++a`) и постфиксные(`a++`) варианты, отличающиеся приоритетом выполнения
            
            ```C++
            \#include <iostream>
            
            int main() {
            	int a = 5;
            	std::cout << ++a << '\n'; // выведет 6, а = 6
            	std::cout << a++ << '\n'; // выведет 6, a = 7
            }
            ```
            
        - `+` / `-`
            
            Унарный минус меняет знак значения. Плюс используется для явного указания положительного значения.
            
            ```C++
            \#include <iostream>
            
            
            int main() {
            	int a = 5;
            	int b = -a;
            	std::cout << a << '\t' << b; // 5 -5
            }
            ```
            
        - Логический оператор НЕ (`!`)
            
            ```C++
            \#include <iostream>
            
            int main() {
            	std::cout << !(5 == -5); // 0
            }
            ```
            
        - Побитовое НЕ (`~`)
            
            Оператор инвертирует каждый бит в двоичной записи числа. Пример:
            
            ```C++
            \#include <iostream>
            
            int main() {
            	unsigned short int a = 13;
            	// 13 = 0000 0000 0000 1101. Инвертируем:
            	// b  = 1111 1111 1111 0010 = 2
            	unsigned short int b = ~a; // 65522
            	std::cout << b;
            }
            ```
            
        - Адрес операнда (`&`)
            
            Извлекает адрес переменной в памяти. Он возвращает ячейку памяти, в которой хранится переменная в памяти компьютера.  
            Используется при инициализации указателей.  
            
            ```C++
            \#include <iostream>
            
            int main() {
            	int a = 14;
            	int* ptr = &a;
            	std::cout << ptr << '\t' << *ptr;
            	// сначала выведется адрес переменной, затем - сама переменная.
            }
            ```
            
        - Разыменовывание указателя (`*`)
            
            Если мы попробуем вывести указатель, то нам выведется адрес, по которому хранится переменная. Для доступа к самой переменной нужно разыменовать указатель:
            
            ```C++
            \#include <iostream>
            
            int main() {
            	int a = 14;
            	int* ptr = &a;
            	std::cout << ptr << '\t' << *ptr;
            }
            ```
            
        - Оператор `sizeof`
            
            Возвращает размер операнда в байтах
            
            ```C++
            \#include <iostream>
            
            int main() {
            	int a = 14;
            	long long b = 1334;
            	std::cout << sizeof(a) << ' ' << sizeof(b); // 4 8
            }
            ```
            
    - Бинарные
        
        ==Арифметические==
        
        - Сумма (`+`)
        - Разность (`-`)
        - Произведение (`*`)
        - Частное (`/`)
        - Остаток (`%`)
        
        ==Логические==
        
        - Больше/больше или равно (`>` / `>=`)
        - Меньше/меньше или равно (`<` / `<=`)
        - Равно/не равно (`==` / `!=`)
        
        Побитовые
        
        - И (`&`)
        - ИЛИ (`|`)
        - Исключающее ИЛИ xor (`^`)
        - Сдвиг влево / вправо (`<<` / `>>`)
    - Тернарные
        
        Тернарный оператор позволяет записывать условия и действия одной строчкой
        
        Синтаксис: `a ? b : c`, где:
        
        - a - условие
        - b - действие, если условие выполняется
        - c - действие, если условия не выполняется
        
        Пример:
        
        ```C++
        \#include <iostream>
        
        int main() {
        	int a;
        	std::cin >> a;
        	(a % 2 == 0) ? std::cout << "Chet" : std::cout << "Nechet";
        }
        ```
        
- ==Типы данных(+ шаблоны)==
    - ==Векторы==
        
        В стандартной библиотеке C++ _вектором_ ([std::vector](https://en.cppreference.com/w/cpp/container/vector)) называется динамический массив, обеспечивающий быстрое добавление новых элементов в конец и меняющий свой размер при необходимости. Вектор гарантирует отсутствие утечек памяти.
        
          
        Для работы с вектором нужно подключить заголовочный файл   
        `vector`.
        
          
        Элементы вектора должны быть одинакового типа, и этот тип должен быть известен при компиляции программы. Он задаётся в угловых скобках после   
        `std::vector`: например, `std::vector<int>` — это вектор целых чисел типа `int`, а `std::vector<std::string>` — вектор строк.
        
          
        Само имя   
        `std::vector` не является типом данных: это _шаблон_, в который требуется подставить нужные параметры (тип элемента), чтобы получился конкретный тип данных.
        
          
        
        Так сложилось, что в стандартной библиотеке индексы и размеры контейнеров имеют беззнаковый тип. Вместо `unsigned int` или `unsigned long int` для него используется традиционный псевдоним `[size_t](https://en.cppreference.com/w/cpp/types/size_t)` (а точнее, `std::vector<T>::size_type`). Тип `size_t` на самом деле совпадает с `uint32_t` или `uint64_t` в зависимости от битности платформы. Его использование в программе дополнительно подчёркивает, что мы имеем дело с индексами или с размером.  
          
          
        
        - Синтаксис
            
            ```C++
            \#include <iostream>
            \#include <vector>
             
            int main() {
                std::vector<int> data = {1, 2, 3, 4, 5};
                for (int elem : data) {
                    std::cout << elem << " ";
                }
                std::cout << "\n";
            }
            ```
            
            ```C++
            \#include <string>
            \#include <vector>
             
            int main() {
                std::vector<std::string> v1;  // пустой вектор строк
                std::vector<std::string> v2(5);  // вектор из пяти пустых строк
                std::vector<std::string> v3(5, "hello");  // вектор из пяти строк "hello"
            }
            ```
            
            ```C++
            std::vector<int> data = {1, 2, 3, 4, 5};
            int a = data[0];  // начальный элемент вектора
            int b = data[4];  // последний элемент вектора (в нём пять элементов)
            data[2] = -3;  // меняем элемент 3 на -3
            ```
            
        - ==Функции==
            - ==Размер вектора(size)==
                
                ```C++
                std::cout << data.size() << "\n";
                ```
                
            - ==Пустой вектор или нет(empty)==
                
                Для проверки вектора на пустоту вместо сравнения `data.size() == 0` принято использовать функцию `empty`, которая возвращает логическое значение  
                  
                
                ```C++
                if (!data.empty()) {
                   // вектор не пуст, с ним можно работать
                }
                ```
                
            - ==Обращение к элементам(at)==
                
                Если вам не хочется делать много лишних проверок, а в корректности индекса вы не уверены, то можно использовать функцию `[at](https://en.cppreference.com/w/cpp/container/vector/at)`:  
                  
                
                ```C++
                std::vector<int> data = {1, 2, 3, 4, 5};
                std::cout << data[42] << "\n";  // неопределённое поведение: может произойти всё что угодно
                std::cout << data.at(0) << "\n";  // напечатается 1
                std::cout << data.at(42) << "\n";  // произойдёт исключение std::out_of_range — его можно будет перехватить и обработать
                ```
                
            - ==Первый и последний элементы(front / back)==
                
                Рассмотрим функции вектора `front` и `back`, которые возвращают его первый и последний элемент без использования индексов  
                  
                
                ```C++
                std::vector<int> data = {1, 2, 3, 4, 5};
                std::cout << data.front() << "\n";  // то же, что data[0]
                std::cout << data.back() << "\n";  // то же, что data[data.size() - 1]
                ```
                
            - ==Добавление и удаление элементов(push_back / pop_back)==
                
                В вектор можно эффективно добавлять элементы в конец и удалять их с конца. Для этого существуют функции `push_back` и `pop_back`. Рассмотрим программу, считывающую числа с клавиатуры в вектор и затем удаляющую все нули в конце:  
                  
                
                ```C++
                \#include <iostream>
                \#include <vector>
                 
                int main() {
                    int x;
                    std::vector<int> data;
                    while (std::cin >> x) {  // читаем числа, пока не закончится ввод
                        data.push_back(x);  // добавляем очередное число в вектор
                    }
                 
                    while (!data.empty() && data.back() == 0) {
                        // Пока вектор не пуст и последний элемент равен нулю
                        data.pop_back();  // удаляем этот нулевой элемент
                    }
                }
                ```
                
            - ==Очистить вектор(clear)==
                
                ```C++
                \#include <iostream>
                \#include <vector>
                int main() {
                    std::vector<int> v = { 1, 2, 3, 4 };
                    std::cout << v.size() << '\n'; // 4
                    v.clear();
                    std::cout << v.size(); // 0
                }
                ```
                
        - Резерв памяти
            
            Вектор хранит элементы в памяти в виде непрерывной последовательности, друг за другом. При этом в конце последовательности резервируется дополнительное место для быстрого добавления новых элементов. Когда этот резерв заканчивается, при вставке очередного элемента происходит _**реаллокация**_: элементы вектора копируются в новый, более просторный блок памяти.
            
            Реаллокация — довольно дорогая процедура, но если она происходит достаточно редко, то её влияние незначительно. Можно доказать, что если размер нового блока выбирать в два раза больше предыдущего размера, то [амортизационная сложность](https://en.wikipedia.org/wiki/Amortized_analysis) добавления элемента будет константной.
            
            Текущий резерв вектора можно узнать с помощью функции `capacity` .
            
            Рассмотрим программу, в которой в вектор последовательно добавляются элементы и после каждого шага печатается размер и резерв:
            
            ```C++
            \#include <iostream>
            \#include <vector>
             
            int main() {
                std::vector<int> data = {1, 2};
                std::cout << data.size() << "\t" << data.capacity() << "\n";
             
                data.push_back(3);
                std::cout << data.size() << "\t" << data.capacity() << "\n";
             
                data.push_back(4);
                std::cout << data.size() << "\t" << data.capacity() << "\n";
             
                data.push_back(5);
                std::cout << data.size() << "\t" << data.capacity() << "\n";
            }
            /*
            2 	2
            3 	4
            4 	4
            5   8
            */
            ```
            
            Видно, что размер вектора увеличивается на единицу, а резерв удваивается после исчерпания. Так, при добавлении четвёрки используется имеющаяся в резерве память, а при добавлении тройки и пятёрки происходит реаллокация.  
              
            Иногда требуется заполнить вектор элементами, причём число элементов известно заранее. В таком случае можно сразу зарезервировать нужный размер памяти с помощью функции   
            `reserve`, чтобы при добавлении элементов не происходили реаллокации. Пусть, например, нам сначала задаётся число слов, а потом сами эти слова, и нам требуется сложить их в вектор  
            Если передать в   
            `reserve` величину меньше текущего резерва, то ничего не поменяется — резерв останется прежним.  
              
              
            
            ```C++
            \#include <iostream>
            \#include <string>
            \#include <vector>
             
            int main() {
                std::vector<std::string> words;
             
                size_t words_count;
                std::cin >> words_count;
             
                // Размер вектора остаётся нулевым, меняется только резерв:
                words.reserve(words_count);
             
                for (size_t i = 0; i != words_count; ++i) {
                    std::string word;
                    std::cin >> word;
                    // Все добавления будут дешёвыми, без реаллокаций:
                    words.push_back(word);
                }
            }
            ```
            
    - ==Строки==
        
        Контейнер `std::string` можно рассматривать как особый случай вектора символов `std::vector<char>`, имеющий [набор дополнительных функций](https://en.cppreference.com/w/cpp/string/basic_string). В частности, у строки есть все те же рассмотренные нами функции, что и у вектора (например, `pop_back` или `resize`). Рассмотрим некоторые специфические функции строки:  
          
        
        ```C++
        \#include <iostream>
        \#include <string>
         
        int main() {
            std::string s = "Some string";
         
            // приписывание символов и строк
            s += ' ';  // добавляем отдельный символ в конец, это аналог push_back
            s += "functions";  // добавляем строку в конец
            std::cout << s << "\n";  // Some string functions
         
            // выделение подстроки
            // подстрока "string" из 6 символов начиная с 5-й позиции
            std::string sub1 = s.substr(5, 6);
            // подстрока "functions" с 12-й позиции и до конца
            std::string sub2 = s.substr(12);
         
            // поиск символа или подстроки
            size_t pos1 = s.find(' ');  // позиция первого пробела, в данном случае 4
            size_t pos2 = s.find(' ', pos1 + 1);  // позиция следующего пробела (11)
            size_t pos3 = s.find("str");  // вернётся 5
            size_t pos4 = s.find("#");  // вернётся std::string::npos
        }
        ```
        
        Вставку, замену и удаление подстрок можно сделать через указание индекса начала и длины подстроки:
        
        ```C++
        \#include <iostream>
        \#include <string>
         
        int main() {
            std::string s = "Some string functions";
         
            // вставка подстроки
            s.insert(5, "std::");
            std::cout << s << "\n";  // Some std::string functions
         
            // замена указанного диапазона на новую подстроку
            s.replace(0, 4, "Special");
            std::cout << s << "\n";  // Special std::string functions
         
            // удаление подстроки
            s.erase(8, 5);  // Special string functions
        }
        ```
        
    - ==Кортеж==
        
        Кортеж - шаблонная структура из заголовочного файла `tuple` . Является обобщением пары. Важно понимать, что типы элементов и размер кортежа фиксируются на этапе компиляции.  
          
        
        ```C++
        \#include <iostream>
        \#include <tuple>
         
        struct Point;  // определена выше
         
        int main() {
            std::tuple<int, double, Point> t = {42, 3.14, {.color = Color::Orange}};
         
            // тут уже нет полей .first и .second,
            // но есть стандартная функция std::get<>,
            // которая принимает в угловых скобках индекс элемента (индексация с нуля):
            std::cout << std::get<0>(t) << "\n";  // 42
            std::cout << std::get<1>(t) << "\n";  // 3.14
            std::cout << std::get<2>(t).x << "\n";  // 0.0
         
            // вызов std::get может появляться и слева от присваивания:
            std::get<2>(t).color = Color::Red;
        }
        ```
        
    - ==Пара==
        
        В заголовочном файле `utility` есть шаблонная структура `[std::pair](https://en.cppreference.com/w/cpp/utility/pair)` с полями `first` и `second`. Из названия просто догадаться, что она хранит два объекта. Важно понимать, что типы элементов пары фиксируются на этапе компиляции.  
          
        
        ```C++
        \#include <iostream>
        \#include <utility>
         
        int main() {
            // в угловых скобках нужно указывать два типа:
            std::pair<int, double> p = {42, 3.14};
         
            // обращаться к полям можно через .first и .second:
            std::cout << p.first << "\n";  // 42
            std::cout << p.second << "\n";  // 3.14
        }
        ```
        
    - Распаковка(пары, кортежа, структуры)
        
        Пару, кортеж или структуру можно «распаковать» с помощью [structured binding](https://en.cppreference.com/w/cpp/language/structured_binding).  
          
        
        ```C++
        \#include <string>
        \#include <utility>
         
        int main() {
            std::pair<std::string, int> p = {"hello", 42};
            auto [word, freq] = p;  // word = "hello"; freq = 42;
        }
        ```
        
        Здесь конструкция `auto [word, freq] = p` вводит две новые переменные `word` и `freq` соответствующих типов и присваивает им значения из пары.
        
    - Структуры
        
        Часто хочется собрать «под одной крышей» несколько переменных. В таких случаях можно использовать структуры. Например, давайте опишем структуру точек из трёхмерного пространства:  
          
        
        ```C++
        struct Point {
            double x = 0.0;
            double y = 0.0;
            double z = 0.0;
        };
        
        int main() {
            Point point1;  // по умолчанию координаты будут нулевыми
         
            Point point2 = {1.4, -2.2, -3.98};
            // x = 1.4, y = -2.2, z = -3.98
         
            point2.z = 32;  // обращаться к полям можно через точку
            point2.x += 2;  // и вообще работать с ними как с обычными переменными
        }
        ```
        
        В С++20 появилась новая форма инициализации структур — [designated initializers](https://en.cppreference.com/w/cpp/language/aggregate_initialization):
        
        ```C++
        int main() {
            Point point3 = {.x = 1.4, .y = -2.2, .z = -3.98};
            Point point4 = {.color = Color::Orange};
        }
        ```
        
        Такой способ записи понятнее: сразу видно, какое поле структуры каким значением инициализируется. Важно, что поля должны быть перечислены в том же порядке, в каком они указываются при описании структуры (причину этого мы узнаем в [параграфе про конструкторы и жизненный цикл объекта](https://academy.yandex.ru/handbook/cpp/article/object-lifetime)). Пропущенные поля будут инициализироваться значением по умолчанию.  
          
          
        
- Шаблоны
    
    [Шаблоны](https://en.cppreference.com/w/cpp/language/templates) — это фрагменты обобщённого кода, в котором некоторые типы или константы вынесены в параметры. Шаблонными могут быть функции, структуры (классы) и даже переменные. Компилятор превращает использование шаблона в конкретный код, подставляя в него нужные параметры на этапе компиляции. Шаблоны позволяют писать общий код, пригодный для использования с разными типами данных.
    
    Стандартная библиотека C++ построена на шаблонах. Раньше её даже называли Standard Template Library (STL, стандартная библиотека шаблонов). Её контейнеры и итераторы являются шаблонными классами, а алгоритмы — шаблонными функциями. Примеры шаблонных конструкций из стандартной библиотеки нам уже встречались: это, например, контейнер `std::vector` и функция `std::sort`.
    
    - Перегрузка
        
        Количество и типы аргументов функции должны быть известны заранее, на этапе компиляции. Но в языке C++ можно создавать функции с одним и тем же именем, но разным набором или типами аргументов и с разными телами. Такие функции называются [перегруженными](https://en.wikipedia.org/wiki/Function_overloading). Рассмотрим, например, семейство перегруженных функций для печати переменной на экран:
        
        ```C++
        \#include <iostream>
        \#include <string>
         
        void Print(int value) {
            std::cout << value << "\n";
        }
         
        void Print(const std::string& name, int value) {
            std::cout << name << ": " << value << "\n";  // печатаем название и саму величину
        }
         
        void Print(const std::string& str) {
            std::cout << str << "\n";
        }
         
        int main() {
            Print(42);  // версия 1
            Print("x", 42);  // версия 2
            Print("good bye");  // версия 3
        }
        ```
        
        - Ошибки
            
            Компилятор, сравнивая разные версии функции друг с другом, смотрит на их имена и набор типов аргументов. При этом имена аргументов ни на что не влияют. Также нельзя перегружать функции по типу возвращаемого значения. Действительно, возвращаемое значение может просто игнорироваться в месте вызова, и компилятор не сможет определить, какая версия функции имеется в виду.
            
            ```C++
            int f(int x) {
                return x;
            }
             
            int f(int y) {  // ошибка компиляции: функция с таким именем и типом параметра уже была
                return 2 * y;
            }
             
            double f(int x) {  // ошибка компиляции: перегружать по возвращаемому значению нельзя
                return 3 * x;
            }
            ```
            
    - Шаблонные функции
        - Пример без шаблона
            
            ```C++
            \#include <iostream>
            \#include <string>
             
            int Max(int x, int y) {
                if (x > y) {
                    return x;
                } else {
                    return y;
                }
            }
             
            double Max(double x, double y) {
                if (x > y) {
                    return x;
                } else {
                    return y;
                }
            }
             
            std::string Max(const std::string& x, const std::string& y) {
                if (x > y) {
                    return x;
                } else {
                    return y;
                }
            }
             
            int main() {
                std::cout << Max(1, 2) << "\n";  // 2
                std::cout << Max(3.14159, 2.71828) << "\n";  // 3.14159
             
                std::string word1 = "hello", word2 = "world";
                std::cout << Max(word1, word2);  // world
            }
            ```
            
        - Пример с шаблоном
            
            Выписывать похожие друг на друга версии функций утомительно. Кроме того, такие функции не смогут работать с новыми, неизвестными нам заранее типами. Шаблоны позволяют описать такую функцию один раз, вынеся тип в параметры:
            
            ```C++
            template <typename T>
            T Max(const T& x, const T& y) {
                if (x > y) {
                    return x;
                } else {
                    return y;
                }
            }
            ```
            
        - Вывод шаблонных параметров
            
            Конкретные версии шаблонной функции `Max` для нужных типов получаются подстановкой шаблонных аргументов в угловые скобки. Так, `Max<int>` — это версия нашей функции для типа `int`, а `Max<std::string>` — версия для строк. Важно понимать, что, несмотря на общий шаблон, это _разные_ функции, которые просто порождаются компилятором по образцу.
            
            Вызвать шаблонную функцию можно было бы так:
            
            ```C++
            Max<double>(3.14159, 2.71828);  // 3.14159
            Max<int>(3.14159, 2.71828);  // вызывается int-версия, вернётся 3
            ```
            
            Однако параметры шаблона в угловых скобках можно не писать: компилятор попытается сам угадать эти параметры по типу аргументов. В случае неоднозначностей, например в вызове `Max(3.14159, 2)`, компилятор не сможет автоматически вывести параметр, и ему придётся подсказать тип: `Max<double>(3.14159, 2)`.  
              
              
            
        - Перегрузка шаблонных функций
            
            Шаблонные функции тоже можно [перегружать](https://en.cppreference.com/w/cpp/language/function_template#Function_template_overloading). Пусть, например, мы хотим вычислять максимум двух векторов, но при этом сравнивать векторы сначала по размеру, а затем уже лексикографически. Стандартное сравнение векторов через оператор `>` не будет учитывать размер. Поэтому напишем отдельную перегрузку для векторов:
            
            ```C++
            \#include <iostream>
            \#include <vector>
             
            // общая версия
            template <typename T>
            T Max(const T& x, const T& y) {
                if (x > y) {
                    return x;
                } else {
                    return y;
                }
            }
             
            // перегрузка для векторов
            template <typename T>
            const std::vector<T>& Max(const std::vector<T>& v1, const std::vector<T>& v2) {
                if (v1.size() > v2.size()) {
                    return v1;
                } else if (v1.size() < v2.size()) {
                    return v2;
                } else if (v1 > v2) {
                    return v1;
                } else {
                    return v2;
                }
            }
             
            int main() {
                std::cout << Max(1, 2) << "\n";  // вызов общей версии
             
                std::vector<int> v1 = {1, 2, 3};
                std::vector<int> v2 = {4, 5};
                for (int x : Max(v1, v2)) {  // вызов перегруженной версии
                    std::cout << x << " ";  // 1 2 3
                }
                std::cout << "\n";
            }
            ```
            
    - Шаблонные структуры
        
        Структуры и классы также могут быть описаны в общем виде и параметризованы типами или константами времени компиляции. Типичный пример шаблонной структуры — `std::pair`. Определим по аналогии свою структуру `Triple` с тремя шаблонными типами:
        
        ```C++
        \#include <string>
         
        template <typename T1, typename T2, typename T3>
        struct Triple {
            T1 first;
            T2 second;
            T3 third;
        };
         
        int main() {
            Triple<int, int, int> point = {-1, 3, 2};
            Triple<std::string, std::string, int> wordPairsFreq = {"hello", "world", 42};
        }
        ```
        
        Здесь так же, как и в случае функций, компилятор генерирует по образцу две никак не связанные друг с другом структуры `Triple<int, int, int>` и `Triple<std::string, std::string, int>`.
        
    
      
    
- Ссылки, указатели, константность
    - Ссылки
        
        В C++ есть возможность обращаться к уже существующему в памяти объекту под другим именем. Рассмотрим это на примере целых чисел:
        
        ```C++
        \#include <iostream>
         
        int main() {
            int x = 42;
            int& ref = x;  // ссылка на x
         
            ++x;
            std::cout << ref << "\n";  // 43
        }
        ```
        
        Здесь `ref` — псевдоним для `x`. Это не самостоятельная переменная, а просто ссылка на объект, уже живущий в памяти. Формально типом `ref` является `int&` — ссылка на `int`.
        
        ==Ссылка должна быть проинициализирована сразу в момент объявления. Ссылка привязана к одному и тому же объекту со своего рождения.==
        
        Давайте запомним: чтобы избегать лишнего копирования, в `range-for` используйте константную ссылку при итерации по набору «тяжёлых» объектов — строк, векторов, структур. Если вы хотите в цикле менять элементы контейнера — используйте обычную ссылку.
        
        ```C++
        \#include <iostream>
        \#include <vector>
         
        int main() {
            const size_t m = 1000000;
            const size_t n = 10000;
            std::vector<std::string> v(m);
            for (const auto& row : v) {  // обычная ссылка
                row.resize(n, '@');
            }
         
            size_t sum = 0;
            for (const auto& row : v) {  // константная ссылка
                sum += row.size();
            }
            std::cout << sum << "\n";
        }
        ```
        
    - Указатели
        
        Другой (более базовый) способ сослаться на что-то уже существующее в памяти — указатели. Это специальные типы данных, которые могут хранить адрес какой-либо другой переменной в памяти. Здесь мы можем представлять себе память как длинную ленту с пронумерованными ячейками (байтами). Сам адрес переменной можно получить с помощью унарного оператора `&` :
        
        ```C++
        int main() {
            int x = 42;
            int* ptr = &x;  // сохраняем адрес в памяти переменной x в указатель ptr
         
            ++x;  // увеличим x на единицу
            std::cout << *ptr << "\n";  // 43
        }
        ```
        
        Формально указатель — это не номер ячейки памяти, а отдельный тип. Но обычно он может быть преобразован к целому числу. Вот такой код напечатает адреса переменных в шестнадцатеричном виде:
        
        ```C++
        \#include <iostream>
         
        int main() {
            int x = 1, y = 2, z = 3;
            std::cout << &x << "\n"; 
            std::cout << &y << "\n";
            std::cout << &z << "\n";
        }
        /*
        0x7ffdfee3188c
        0x7ffdfee31888
        0x7ffdfee31884
        */
        ```
        
        Кроме адреса ячейки памяти переменная-указатель обладает ещё и типом данных, значение которого в этой ячейке лежит. Это позволяет компилятору правильно интерпретировать обращение к памяти по этому адресу. Поэтому мы используем не какой-либо абстрактный тип «указатель», а именно «указатель на `int`».
        
        Оператор разыменования (унарная звёздочка) противоположен оператору взятия адреса (унарному амперсанду). Сравните: `&x` — это адрес `x` в памяти, а `*ptr` — это значение, живущее по адресу, записанному в `ptr`.
        
        Указатели, в отличие от ссылок, можно переназначать. Кроме того, есть выделенное значение никуда не ссылающегося указателя — `nullptr` («нулевой» указатель):
        
        ```C++
        \#include <iostream>
         
        int main() {
            int x = 42, y = 13;
            int* ptr;  // по умолчанию не инициализируется, тут лежит «случайный» адрес
            ptr = nullptr;  // «нулевой» указатель
            ptr = &x;  // теперь в ptr лежит адрес переменной x
            std::cout << *ptr << "\n";  // 42
            ptr = &y;  // можно поменять адрес, записанный в ptr
            std::cout << *ptr << "\n";  // 13
        }
        ```
        
        Отдельно рассмотрим указатели на структуру. Для обращения к полям структуры через указатель есть отдельный оператор `->`:
        
        ```C++
        \#include <iostream>
         
        struct Point {
            double x, y, z;
        };
         
        int main() {
            Point p = {3.0, 4.0, 5.0};
         
            Point* ptr = &p;
         
            std::cout << (*ptr).x << "\n";  // обращение через * и . требует скобок
            std::cout << ptr->x << "\n";  // то же самое, но чуть короче
        }
        ```
        
    - Константность(==Nightmare==)
        
        Ссылки и указатели можно комбинировать с константностью:
        
        ```C++
        int main() {
            int x = 42;
         
            int& ref = x;  // обычная ссылка
            const int& cref = x;  // константная ссылка
            ++x;  // OK
            ++ref;  // OK
            ++cref;  // ошибка компиляции: псевдоним cref предназначен только для чтения
         
            int* ptr = &x;  // обычный указатель
            const int* cptr = &x;  // указатель на константу
            ++*ptr;  // OK
            ++*cptr;  // ошибка компиляции: разыменованный cptr — константа!
        }
        ```
        
        Если исходная переменная уже была константной, то взять обычную ссылку или указатель на неё не получится. Другими словами, константность нельзя просто так отменить, её можно только добавить:
        
        ```C++
        int main() {
            const int cx = 42;
         
            int& ref = cx;  // ошибка компиляции: константность нельзя убрать
            const int& cref = cx;  // OK
         
            int* ptr = &cx;  // тоже ошибка компиляции
            const int* cptr = &cx;  // OK
        }
        ```
        

---

- ==Стандартная библиотека С++==
    
    [[Последовательные контейнеры]]
    
    [[Ассоциативные контейнеры]]
    
    - ==Алгоритмы== ==стандартной== ==библиотеки==
        
        Большинству алгоритмов, работающих с контейнерами, в круглых скобках передаётся пара итераторов(Чаще всего `begin` и `end`, иногда `rbegin` и `rend`)
        
        Основные алгоритмы:
        
        - Сортировка (`sort`)
            
            Рассмотрим типичную задачу — отсортировать вектор по возрастанию. Для этого в стандартной библиотеке в заголовочном файле `algorithm` есть готовая функция `[sort](https://en.cppreference.com/w/cpp/algorithm/sort)`. Гарантируется, что сложность её работы в худшем случае составляет O(n log n):
            
            ```C++
            \#include <algorithm>
            \#include <vector>
             
            int main() {
                std::vector<int> data = {3, 1, 4, 1, 5, 9, 2, 6};
             
                // Сортировка диапазона вектора от начала до конца
                std::sort(data.begin(), data.end());
             
                // получим вектор 1, 1, 2, 3, 4, 5, 6, 9
            }
            ```
            
            В функцию `sort` передаются так называемые _итераторы_, ограничивающие рассматриваемый диапазон. В нашем случае мы передаём диапазон, совпадающий со всем вектором, от начала до конца. Соответствующие итераторы возвращают функции `begin` и `end` (не путать с `front` и `back`!). Итераторы можно считать обобщёнными индексами (но они могут быть и у контейнеров, не допускающих обычную индексацию). Подробнее про итераторы мы поговорим в отдельном параграфе.
            
            Для сортировки по убыванию можно передать на вход _обратные итераторы_ `rbegin()` и `rend()`, представляющие элементы вектора в перевёрнутом порядке:  
              
            
            ```C++
            std::sort(data.rbegin(), data.rend());  // 9, 6, 5, 4, 3, 2, 1, 1
            ```
            
            - Настраиваемая сортировка
                
                Пусть имеется структура `Date`, описывающая день, месяц и год какой-то даты. Создадим вектор дат:
                
                ```C++
                \#include <algorithm>
                \#include <iostream>
                \#include <vector>
                 
                struct Date {
                    int year = 1970;
                    int month = 1;
                    int day = 1;
                };
                 
                int main() {
                    std::vector<Date> dates = {
                        {2020, 3, 15},
                        {2019, 1, 21},
                        {2021, 1, 30}
                    };
                 
                    // напечатаем содержимое:
                    for (const auto& [year, month, day] : dates) {
                        std::cout << year << "." << month << "." << day << "\n";
                    }
                }
                ```
                
                Предположим, нам требуется отсортировать даты. Для сортировки нам поможет уже знакомая функция `std::sort`, но есть нюанс: вызов `std::sort(dates.begin(), dates.end())` не скомпилируется, так как компилятор не умеет сравнивать даты между собой. Функция `std::sort` пытается найти оператор `<` для сравнения дат, но, увы, для нашей даты такого нет. Мы можем его определить. Он выглядит как функция с особым именем `operator <`, возвращающая `true`, если первый аргумент меньше второго:
                
                ```C++
                bool operator < (const Date& lhs, const Date& rhs) {
                    return std::tie(lhs.year, lhs.month, lhs.day) < std::tie(rhs.year, rhs.month, rhs.day);
                }
                ```
                
                Здесь `lhs` и `rhs` — сокращения от left-hand side и right-hand side. Это левый и правый аргументы оператора `<`. Функция `[std::tie](https://en.cppreference.com/w/cpp/utility/tuple/tie)` возвращает кортеж из ссылок, для которого уже определено лексикографическое (покомпонентное) сравнение.
                
                - Код без `std::tie` 
                    
                    ```C++
                    bool operator < (const Date& lhs, const Date& rhs) {
                        if (lhs.year != rhs.year) {
                            return lhs.year < rhs.year;
                        }
                        if (lhs.month != rhs.month) {
                            return lhs.month < rhs.month;
                        }
                        return lhs.day < rhs.day;
                    }
                    ```
                    
                
                После определения `operator <` сортировка заработает. Но что, если нам в разных случаях нужно по-разному сортировать даты — например, где-то в хронологическом порядке, а где-то — без учёта года? Можно передать в `std::sort` третьим аргументом свою функцию сравнения, которая будет использована вместо `operator <`:
                
                ```C++
                bool CompareWithoutYear(const Date& lhs, const Date& rhs) {
                    return std::tie(lhs.month, lhs.day) < std::tie(rhs.month, rhs.day);
                }
                 
                int main() {
                    // ...
                    std::sort(dates.begin(), dates.end(), CompareWithoutYear);
                }
                ```
                
        - Подсчёт определённых элементов (`count`)
            
            Рассмотрим, пожалуй, самый простой пример — алгоритм `[std::count](https://en.cppreference.com/w/cpp/algorithm/count)`. Эта функция подсчитывает, сколько элементов последовательности равны заданному.
            
            ```C++
            \#include <algorithm>
            \#include <iostream>
            \#include <vector>
             
            int main() {
                std::vector<int> v = {2, 7, 1, 8, 2, 8};
                std::cout << std::count(v.begin(), v.end(), 8) << "\n";  // 2
            }
            ```
            
            - Своя функция count
                
                ```C++
                template <typename Iter, typename Value>  // два шаблонных параметра: тип итератора и тип эталонного элемента
                int count(Iter first, Iter last, const Value& value) {
                    int counter = 0;
                    for (Iter iter = first; iter != last; ++iter) {
                        if (*iter == value) {
                            ++counter;
                        }
                    }
                    return counter;
                }
                ```
                
        - Поиск (`find`)
            
            Алгоритм `[std::find](https://en.cppreference.com/w/cpp/algorithm/find)` ищет последовательным перебором первое вхождение элемента, равного заданному. Результатом является итератор, который указывает на найденный элемент. Если же ничего не найдено, то возвращается правый конец переданного полуинтервала.
            
            ```C++
            \#include <algorithm>
            \#include <deque>
            \#include <iostream>
             
            int main() {
                std::deque<int> d = {3, 14, 15, 92, 6};
             
                // Такой элемент есть, мы его точно найдём
                auto iter1 = std::find(d.begin(), d.end(), 15);
                // Итераторы дека можно вычитать, напечатается индекс найденного элемента
                std::cout << (iter1 - d.begin()) << "\n";
             
                auto start = d.begin();
                // К итераторам дека и вектора можно прибавлять целые числа
                auto end = start + 3;
                // Полуинтервал [start; end) теперь ограничивает подпоследовательность 3, 14, 15
             
                auto iter2 = std::find(start, end, 19);
                if (iter2 == end) {
                    std::cout << "No such element!\n";
                } else {
                    std::cout << *iter2 << "\n";
                }
                // Напечатает No such element
            }
            ```
            
            - Своя реализация алгоритма
                
                ```C++
                template <typename Iter, typename Value>
                Iter find(Iter first, Iter last, const Value& value) {
                    while (first != last) {
                        if (*first == value) {
                            return first;
                        }
                        ++first;
                    }
                    return last;
                }
                ```
                
        - Переворот (`reverse`)
            
            Рассмотрим алгоритм `[std::reverse](https://en.cppreference.com/w/cpp/algorithm/reverse)`. Он переставляет элементы последовательности в обратном порядке:
            
            ```C++
            \#include <algorithm>
            \#include <iostream>
            \#include <string>
             
            int main() {
                std::string s = "No lemon, no melon!";
                std::reverse(s.begin(), s.end());
                std::cout << s << "\n";  // !nolem on ,nomel oN
            }
            ```
            
        - ПРИМЕЧАНИЕ
            
            Общая идея, заложенная в дизайн стандартной библиотеки C++: если некоторый алгоритм имеет более эффективную реализацию для конкретного контейнера, то он будет реализован у этого контейнера в виде встроенной функции. Наоборот, если возможна лишь общая реализация, то специальной встроенной функции не будет. Поэтому, например, у вектора и дека нет своей встроенной функции `find`.
            
        
        Остальные алгоритмы:
        
        [[Алгоритмы]]
        
    
    [[Адаптеры над контейнерами]]
    
    - Представления
        
        _Представления_ (views) не владеют памятью, а лишь ссылаются на диапазон значений другого контейнера. Представлением можно считать пару итераторов. В С++20 появилась обширная библиотека `[ranges](https://en.cppreference.com/w/cpp/ranges)` для работы с представлениями.
        
        - Представление строки (`string_view`)
            
            Конструкция `[std::string_view](https://en.cppreference.com/w/cpp/string/basic_string_view)` не является адаптером. Это не самостоятельная строка, а отсылка к подстроке какой-то другой строки. Объекты такого класса не выделяют память для размещения символов строки и не копируют подстроки. Упрощённо их можно представлять себе просто как такие структуры:
            
            ```C++
            struct string_view {
                const char* start;  // указатель на начало подстроки в чужой памяти
                size_t len;   // длина этой подстроки
            };
            ```
            
            ![[Untitled.png]]
            
            ```C++
            \#include <iostream>
            \#include <string>
            \#include <string_view>
             
            int main() {
                std::string s = "Hello, world! How do you do?";
                std::string_view sv = s;  // смотрим через string_view на строку s
                auto sub = sv.substr(7, 5);  // теперь тип sub — std::string_view
                // sub[0] = 'W';  // изменять через string_view символы строки нельзя
                std::cout << sub << "\n";  // world
                std::cout << s << "\n";  // Hello, world! How do you do?
            }
            ```
            
            Обёртка `string_view` рассматривает исходную строчку как константную: она не позволяет её изменять. В то же время через `string_view` можно читать символы фрагмента исходной строки, а также можно брать новые подстроки и сужать длину подстрок
            
            ```C++
            \#include <iostream>
            \#include <string>
            \#include <string_view>
             
            int main() {
                std::string s = "Hello, world! How do you do?";
                std::string_view sv = s;
                sv.remove_prefix(7);  // убрали из sv первые 7 символов
                sv.remove_suffix(16);  // убрали последние 16 символов
                std::cout << sv << "\n";  // world
                std::cout << s << "\n";  // строка s при этом никак не изменилась
            }
            ```
            
            Обёртка `string_view` позволяет избежать ненужных копирований и ускорить программу там, где ведётся работа с подстроками одной большой строки. Например, это могут быть фрагменты JSON- или XML-файлов. Однако важно помнить, что `string_view` валиден только при условии, что объемлющая строка жива. Например, следующая программа некорректна и приведёт к неопределённому поведению:
            
            ```C++
            \#include <iostream>
            \#include <string>
            \#include <string_view>
            \#include <vector>
             
            int main() {
                std::vector<std::string_view> lines;
                for (int i = 0; i < 5; ++i) {
                    std::string line;
                    std::getline(std::cin, line);
                    lines.push_back(line);  // string_view в векторе ссылается на память строки line
                }
                for (auto item : lines) {
                    std::cout << item << "\n";  // Ошибка! Все эти строки уже невалидны!
                }
            }
            ```
            
            Программа компилируется, но при запуске попадает в неопределённое поведение, так как исходные строки `line` выходят из своей области видимости после каждой итерации цикла, и обращаться к их памяти больше нельзя.
            
        - Представление последовательного контейнера (`span`)
            
            ```C++
            \#include <iostream>
            \#include <vector>
            \#include <span>
            
            int main() {
                std::vector<int> v = { 1, 2, 3, 4, 5, 6, 7, 8 };
                std::span<int> sp(v.begin() + 1, v.end() - 1);
                for (auto elem : sp) {
                    std::cout << elem << ' '; // 2, 3, 4, 5, 6, 7
                }
            }
            ```
            

---

- Классы
    - Основа
        
        Классы похожи на структуры: это пользовательские типы данных, в которых хранятся _поля_. Синтаксически даже ключевые слова `struct` и `class` взаимозаменяемы (только объявления внутри `struct` по умолчанию публичны, а внутри `class` — приватны, об этом ниже). Однако мы будем различать семантику структуры и класса:
        
        1. Мы будем использовать `struct` в типах, где не требуется сложная логика по инициализации и обработке значений. Структуры — это просто набор полей, не связанных какими-либо ограничениями.
        2. Мы будем использовать `class` там, где требуются какие-либо действия при инициализации и обработке данных. Класс предполагает некоторый _инвариант_: он не позволяет изменить данные произвольным образом. Хороший пример — `class Time`, который мы рассмотрим ниже. Часы, минуты и секунды не могут быть произвольными числами, и класс должен гарантировать, что они всегда корректны.
        
        [[Класс Time]]
        
    - Публичное одиночное наследование
        
        Наследование - передача дочернему классу публичных полей и методов родительского класса
        
        [[Наследование]]
        
- Генератор случайных чисел
    
    Он реализуется функцией `rand()`. Но на самом деле числа псевдослучайные, так как отталкиваются от определённой точки, задаваемой функцией `srand()` (random seed), принимающей на вход какое-нибудь число. Чтобы вручную не менять число на вход srand(), можно подключить библиотеку, отвечающую за время:
    
    ```C++
    \#include <iostream>
    \#include <ctime>
    int main() {
    	int a;
    	std::cout << time(NULL);
    	srand(time(NULL));
    	std::cout << rand() << '\n';
    	// Чтобы задать диапазон, используем арифметические операции:
    	std::cout << rand() % 10 << '\n'; // числа от 0 до 9
    	std::cout << rand() % 30 + 4; // числа от 4 до 33
    }
    ```
    
- Жизненный цикл объекта
    - Конструктор / деструктор
        
        Конструктор вызывается при объявлении/инициализации объекта класса, а деструктор - когда объект выходит из ==области видимости== программы. Пример:
        
        ```C++
        \#include <iostream>
        
        class Logger {
        private:
        
        public:
            Logger() {
                std::cout << "Конструктор" << '\n';
            }
        
        
            ~Logger() {
                std::cout << "Деструктор" << "\n";
            }
        };
        
        int main() {
            setlocale(LC_ALL, "Rus");
            Logger x1;
            std::cout << ":)" << '\n';
        
        }
        
        /*
        >> Конструктор
        >> :)
        >> Деструктор
        */
        ```
        
        Сначала создаётся объект, затем выполняется `std::cout << ":)" << '\n';` , а потом объект уничтожается.
        
    - Статистические поля и функции
        
        Ключевое слово `static` в C++ используется в [нескольких разных смыслах](https://en.cppreference.com/w/cpp/keyword/static).
        
        В объявлении поля в классе оно обозначает, что значение этого поля [одинаково для всех объектов класса](https://en.cppreference.com/w/cpp/language/static#Static_data_members). Фактически, статическое поле является глобальной переменной, которую просто поместили в класс как в пространство имён. Ниже мы пользуемся словом `static` в сочетании с `inline` — этот синтаксис позволяет инициализировать такие поля прямо в классе:
        
        ```C++
        \#include <iostream>
        
        class Test {
        public:
            inline static int count = 0; // Статическое поле, проинициализированное прямо в классе
            static const int cnst = 100; // Статическая константа
        };
        
        int main() {
            Test t1, t2;
            std::cout << t1.count << ' ' << t2.count << '\n';
            Test::count = 5; // обращаемся напрямую
            std::cout << t1.count << ' ' << t2.count << '\n';
            t1.count = 7; // обращаемся через объект
            std::cout << t1.count << ' ' << t2.count << '\n';
        
        }
        ```
        
    - Конструктор копирования и присваивания
        
        Воспользуемся глобальным счётчиком, чтобы различать объекты между собой:
        
        ```C++
        \#include <iostream>
        
        class Logger { 
        private:
            inline static int counter = 0;
            const int id;
        public:
            Logger():
                id(++counter)
            {
                std::cout << "Конструктор: " << id << '\n';
            }
        
            Logger(const Logger& other):
            id(++counter) {
                std::cout << "Конструктор копирования: " << id << '(' << other.id << ')' << '\n';
            }
        
            Logger& operator = (const Logger& other) {
                std::cout << "Оператор присваивания: " << id << '(' << other.id << ')' << '\n';
                return *this;
            }
        
            ~Logger() {
                std::cout << "Деструктор: " << id << "\n";
            }
        };
        
        int main() {
            setlocale(LC_ALL, "rus");
            Logger x1;
            Logger x2 = x1; // Копирование
            Logger x3;
            x3 = x1; // Присваивание
        }
        ```
        
    - Работа с временными объектами
        
        Рассмотрим такой код:
        
        ```C++
        \#include <iostream>
        
        void f(const Logger& x) {
            std::cout << "void f(const Logger&)\n";
        }
        
        int main() {
            f(Logger());
            std::cout << "Hello!\n";
        }
        /*
        Конструтор: 1
        void f(const Logger&)
        Деструктор: 1
        Hello!
        */
        ```
        
        Здесь мы передаём в функцию `f` _временный объект_ `Logger()`. У него нет имени. Он существует лишь пока вычисляется выражение `f(Logger())`. Поэтому сообщение о вызове его деструктора мы увидим до строки `Hello!`
        
        В C++ имеется возможность различать в функциях временные и обычные объекты. Напишем перегруженную версию функции `f`, принимающую на вход так называемую [rvalue-ссылку](https://en.cppreference.com/w/cpp/language/reference#Rvalue_references):
        
        ```C++
        \#include <iostream>
        
        void f(const Logger& x) {  // версия для обычных аргументов
            std::cout << "void f(const Logger&)\n";
        }
        
        void f(Logger&& x) {  // версия для временных аргументов типа Logger
            std::cout << "void f(Logger&&)\n";
        }
        
        int main() {
            f(Logger());  // вызывается перегруженная версия для временных аргументов
            std::cout << "\n";
        
            Logger x;
            f(x);  // вызывается обычная версия
            std::cout << "\n";
        }
        /*
        Logger(): 1
        void f(Logger&&)
        ~Logger(): 1
        
        Logger(): 2
        void f(const Logger&)
        
        ~Logger(): 2
        */
        ```
        
        Термин «временный объект», который мы используем, не совсем корректен. Правильнее было бы говорить об [объектах категории prvalue или xvalue](https://en.cppreference.com/w/cpp/language/value_category), но мы не будем сейчас переусложнять наш рассказ. Добавим только, что обычный объект можно принудительно рассмотреть как временный, применив к нему функцию `[std::move](https://en.cppreference.com/w/cpp/utility/move)` из заголовочного файла `utility`. Это может потребоваться для вызова правильной перегруженной версии какой-либо функции.
        
        Давайте добавим в наш класс `Logger` _конструктор перемещения_ и оператор присваивания, которые будут принимать временный объект.
        
        ```C++
        class Logger {
            // ...
        
        public:
            // ...
        
            // Конструктор перемещения:
            Logger(Logger&& other): id(++counter) {
                std::cout << "Конструктор перемещения: " << id << " " << other.id << "\n";
            }
        
            Logger& operator = (Logger&& other) {
                std::cout << "Присваивание временного объекта: " << id << " " << other.id << "\n";
                return *this;
            }
        };
        
        int main() {
            setlocale(LC_ALL, "rus");
            Logger x1;
            Logger x2(std::move(x1));
            x2 = Logger();
        }
        /*
        Конструктор: 1
        Конструктор перемещения: 2 1
        Конструктор: 3
        Присваивание временного объекта: 2 3
        Деструктор: 3
        Деструктор: 2
        Деструктор: 1
        */
        ```
        
    - Объекты в контейнерах
        
        Воспользуемся контейнером `std::list` :
        
        ```C++
        int main() {
            setlocale(LC_ALL, "rus");
            std::list<Logger> container;
        
            container.push_back(Logger());
        
            Logger x;
            container.push_back(x);
            container.emplace_back();
        }
        
        /*
        Конструктор: 1
        Конструктор перемещения(временный объект): 2 1
        Деструктор: 1
        Конструктор: 3
        Конструктор копирования: 4(3)
        Конструктор: 5
        Деструктор: 3
        Деструктор: 2
        Деструктор: 4
        Деструктор: 5
        */
        ```
        
        1. Передали временный объект, который скопировался в контейнер - сработал ==конструктор перемещения====, временный объект сразу же уничтожился==
        2. Создали x и передали его, он скопировался в контейнер - сработал ==конструктор копирования==
        3. Метод emplace_back вставляет в конец контейнера объект, проинициализированный по дефолту - сработал обычный ==конструктор==
        
        ==ЗАМЕТИМ====, в== ==`std::list`== ==элементы удаляются с начала.==
        
    - Стек/динамическая память
        
        Попробуем создать три объекта Logger:
        
        ```C++
        int main() {
            setlocale(LC_ALL, "rus");
            Logger x1, x2, x3;
        }
        
        /*
        Конструктор: 1
        Конструктор: 2
        Конструктор: 3
        Деструктор: 3
        Деструктор: 2
        Деструктор: 1
        */
        ```
        
        Заметим, что объекты уничтожаются в порядке, обратном порядку их создания. Это происходит, потому что объекты создаются в стеке - идя ==LIFO== ==- last in - first out.==
        
        ![[image.png]]
        
        Модель стека не всегда подходит для создания объектов. Например, функция `push_back` для добавления нового элемента в `std::list` не может создать новый узел на стеке: он бы автоматически разрушился деструктором при выходе из функции.
        
        В C++ можно управлять жизнью объекта вручную. Ручные объекты будут расположены уже не на стеке, а в _динамической памяти_. Программист сам должен следить за временем жизни таких объектов и удалять их, когда они не нужны. Создаются такие объекты конструкцией `new`, которая выбирает свободный блок памяти, создаёт там объект и возвращает указатель на эту память. Такие объекты необходимо обязательно удалять конструкцией `delete`, когда они станут не нужны.
        
        ```C++
        int main() {
            Logger* ptr1 = new Logger();
            Logger* ptr2 = new Logger();
        
            delete ptr1;  // удаляем сначала объект *ptr1
            delete ptr2;  // потом удаляем *ptr2
        }
        /*
        Конструктор: 1
        Конструктор: 2
        Деструктор: 1
        Деструктор: 2
        */
        ```
        
        ![[image 1.png]]
        
    - Тестовый класс (==Logger==)
        
        ```C++
        \#include <iostream>
        
        class Logger {
        private:
            inline static int counter = 0;
            const int id;
        public:
            Logger() :
                id(++counter) {
                std::cout << "Конструктор: " << id << '\n';
            }
            
            Logger(int x) :
                id(++counter) {
                std::cout << "Конструктор(int): " << id << '\n';
            }
        
            Logger(const Logger& other) :
                id(++counter) {
                std::cout << "Копирование: " << id << '(' << other.id << ')' << '\n';
            }
            
            Logger(Logger&& other) : id(++counter) {
                std::cout << "Конструктор перемещения: " << id << " -> " << other.id << '\n';
            }
        
            Logger& operator = (Logger&& other) {
                std::cout << "Присваивание с использованием 'временного объекта': " << id << " -> " << other.id << '\n';
                return *this;
            }
        
            Logger& operator = (const Logger& other) {
                std::cout << "Присваивание: " << id  << " -> " << other.id << '\n';
                return *this;
            }
        
        
            ~Logger() {
                std::cout << "Деструктор: " << id << "\n";
            }
        };
        
        int main() {
            setlocale(LC_ALL, "Rus");
            Logger x1;
            Logger x1_1 = x1;
            Logger x3;
            x3 = x1;
            Logger x4(std::move(x1));
            Logger x5;
            x5 = std::move(x1);
        
        }
        ```
-  L-value и R-value
	l-value - объект в памяти, на который можно ссылаться и изменять. Может быть слева от знака присваивания.
	r-value - временное значение, не связанное с фиксированным местом в памяти.