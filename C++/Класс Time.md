- 1. Объявление класса
    
    Три наших поля в классе будут объявлены в [приватной](https://en.cppreference.com/w/cpp/language/access#Private_member_access), или закрытой области. Это значит, что доступ к ним будут иметь только особо указанные [дружественные функции](https://en.cppreference.com/w/cpp/language/friend) и [функции из класса](https://en.cppreference.com/w/cpp/language/member_functions) (member functions). Кстати, в других языках программирования функции из класса именуют _методами_, но в стандарте C++ термина «метод» нет.
    
    В [публичной](https://en.cppreference.com/w/cpp/language/access#Private_member_access) области объявим _конструктор_ для начальной инициализации переменной класса `Time` и три функции для чтения полей:
    
    ```C++
    class Time {
    private:
        int hours;
        int minutes;
        int seconds;
     
    public:
        Time(int h, int m, int s);  // объявляем конструктор
     
        // Объявляем три функции для чтения полей:
        int GetHours() const;
        int GetMinutes() const;
        int GetSeconds() const;
    };
    ```
    
    Здесь мы пока только _объявили_ эти функции, но пока не написали их тела. Мы это сделаем чуть позже. А пока обратите внимание, что конструктор — это особая функция, которая вызывается при создании объекта. Имя конструктора совпадает с именем класса, а возвращаемое значение не указывается. Три функции `GetHours`, `GetMinutes` и `GetSeconds` объявлены _константными_ — с пометой `const` в конце. Это значит, что эти функции не могут менять состояние объекта (в нашем случае — не изменяют значения полей `hours`, `minutes` и `seconds`).
    
    Фактически мы скрыли детали реализации нашего класса и предоставили [публичный интерфейс](https://en.wikipedia.org/wiki/Class_(computer_programming)\#The_concept_of_class_interface) — набор функций, через которые можно что-то сделать с объектом.
    
- 2. Определение функций из класса
    
    Давайте теперь _определим_ эти функции, — то есть, напишем их тела. Это можно сделать прямо внутри объявления класса (и дальше мы будем для краткости писать их именно так). Но, вообще говоря, определить функцию из класса можно и отдельно. Пишем после объявления класса:
    
    ```C++
    Time::Time(int h, int m, int s) {
        if (s < 0 || s > 59) {
            // обрабатываем ошибочные секунды
        }
        if (m < 0 || m > 59) {
            // обрабатываем ошибочные минуты
        }
        if (h < 0 || h > 23) {
            // обрабатываем ошибочные часы
        }
        hours = h;
        minutes = m;
        seconds = s;
    }
     
    int Time::GetHours() const {
        return hours;
    }
     
    int Time::GetMinutes() const {
        return minutes;
    }
     
    int Time::GetSeconds() const {
        return seconds;
    }
    ```
    
    Обратите внимание, что при внешнем определении функции из класса мы предваряем её имя префиксом с именем класса и двумя двоеточиями. Это напоминает пространства имён (вспомните, что мы везде пишем `std::` перед именами из стандартной библиотеки).
    
    Тела функций из класса написаны так, как будто поля этого неявно переданного объекта попали в текущую область видимости. Сам же этот объект доступен в теле функции через указатель `this`. Можно было бы написать
    
    ```C++
    int Time::GetHours() const {
        return this->hours;  // то же самое, что (*this).hours
    }
    ```
    
    Но так обычно не пишут. То, что `this` — это указатель, а не более удобная ссылка, — историческое недоразумение.
    
- 3. Конструктор и обработка ошибок
    
    Вернёмся к нашему конструктору. Мы пока не написали в нём код обработки ошибочных аргументов. Было бы слишком плохо просто выйти из конструктора в случае ошибки:
    
    ```C++
    Time::Time(int h, int m, int s) {
        if (s < 0 || s > 59) {
            return;
        }
        // ...
    }
    ```
    
    В таком случае как ни в чём не бывало был бы создан объект, причём его поля никак не были бы проинициализированы. Поскольку у полей примитивный тип `int`, то в них, как и в непроинициализированных локальных переменных, содержался бы «мусор»:
    
    ```C++
    \#include <iostream>
     
    int main() {
        Time t(42, -5, 61);
     
        // Неопределённое поведение: может быть напечатано всё, что угодно:
        std::cout << t.GetHours() << "\n";
    }
    ```
    
    Программисту надо решить, как должен вести себя конструктор в этой ситуации. Есть два варианта:
    
    - Сгенерировать ==исключение==
        
        Сгенерировать _исключение_ — специальное сообщение об ошибке. Работа конструктора в этом случае прерывается. Объект не считается созданным. Такое исключение должно быть перехвачено специальным обработчиком `try`/`catch`.
        
        ```C++
        \#include <stdexcept>
         
        Time::Time(int h, int m, int s) {
            if (s < 0 || s > 59 || m < 0 || m > 59 || h < 0 || h > 23) {
                throw std::out_of_range("Wrong time!");
            }
            // ...
        }
        ```
        
    - Всё же ==создать объект==, выполнив инициализацию его полей какими-то значениями.
        
        Приведём часы, минуты и секунды к привычной шкале, перекидывая лишнее в другие разряды.
        
        ```C++
        Time::Time(int h, int m, int s) {
            m += s / 60;
            s %= 60;
            // Если s было отрицательным, то остаток тоже будет отрицательным
            if (s < 0) {
                // Уменьшим в этом случае минуты и сделаем секунды положительными
                m -= 1;
                s += 60;
            }
         
            h += m / 60;
            m %= 60;
            if (m < 0) {
                h -= 1;
                m += 60;
            }
         
            h %= 24;
            if (h < 0) {
                h += 24;
            }
         
            hours = h;
            minutes = m;
            seconds = s;
        }
        ```
        
        Теперь все создаваемые объекты класса `Time` будут поддерживать инвариант «время задано корректно в пределах от 00:00:00 до 23:59:59»:
        
- 4. Перегрузка конструкторов
    
    Чтобы можно было создать объект, не указав параметры или указав их в формате, отличном от обычного, достаточно ==перегрузить конструктор:==
    
    ```C++
    class Time {
    private:
        int hours = 0;
        int minutes = 0;
        int seconds = 0;
     
    public:
        Time() = default;
     
        Time(int h, int m, int s);  // этот конструктор уже был написан раньше
     
        Time(int s): Time(0, 0, s) {
        }
    };
    ```
    
    Здесь мы объявили конструктор `Time()` с пометой `default`. Это значит, что компилятор сгенерирует его по умолчанию (в данном случае с пустым телом). Такая пометка встретится нам дальше при изучении других специальных функций класса. Конечно, мы могли бы просто написать тут пустое тело, но `default` здесь выразительнее.
    
    Конструктор `Time(int s)` объявлен [делегирующим](https://en.cppreference.com/w/cpp/language/constructor#Delegating_constructor): он ссылается на другой конструктор.
    
- 5. Константные и неконстантные функции из класса
    
    Сейчас мы можем проинициализировать объекты класса `Time` только в момент создания и далее никак не можем их изменить. Они пока ведут себя как константы. Давайте теперь добавим в класс функции для изменения состояния объекта. Напишем функцию `AddSeconds`, которая добавляет ко времени заданное количество секунд. Для краткости определим её тело прямо внутри объявления класса, а тела конструктора и `Get`-функций не будем повторять:
    
    ```C++
    class Time {
    private:
        int hours, minutes, seconds;
     
    public:
        Time(int h, int m, int s);
     
        int GetHours() const;
        int GetMinutes() const;
        int GetSeconds() const;
     
        void AddSeconds(int s) {
            seconds += s;
            // дальше следует выполнить такие же преобразования, как в конструкторе
        }
    };
    ```
    
    - ==Удобно оформить нормализацию в виде отдельной приватной функции `Normalize`.==
        
        Её потребуется вызывать только в конструкторе и в функции `AddSeconds`, а внешним пользователям класса она не нужна. Фактически, эта функция будет поддерживать _[инвариант класса](https://en.wikipedia.org/wiki/Class_invariant)_.
        
        ```C++
        class Time {
        private:
            int hours, minutes, seconds;
         
            void Normalize() {
        		    minutes += seconds / 60;
        		    hours += minutes / 60;
        		    hours = hours % 24;
        		    minutes = minutes % 60;
        		    seconds = seconds % 60;
        		}
         
        public:
            Time(int h, int m, int s) {
                hours = h;
                minutes = m;
                seconds = s;
                Normalize();
            }
         
            void AddSeconds(int s) {
                seconds += s;
                Normalize();
            }
         
            int GetHours() const;
            int GetMinutes() const;
            int GetSeconds() const;
        };
        ```
        
- 6. Перегрузка операторов
    - Оператор сложения
        
        Вместо вызова `t.AddSeconds(40)` было бы заманчиво написать просто `t += 40`. Для этого нужно [перегрузить](https://en.cppreference.com/w/cpp/language/operators) соответствующие арифметические операторы для нашего класса. А для этого достаточно переименовать нашу функцию `AddSeconds` в `operator +=`.
        
        Согласно канонам, такой оператор обычно возвращает ссылку на текущий объект `*this`. В выражении `t += 40` это возвращаемое значение игнорируется, однако оно позволяет писать странные цепочки вида `(t += 40) += 20`. Не будем отступать от традиции:
        
        ```C++
        class Time {
           // пропустим объявления полей и функций
         
        public:
           Time& operator += (int s) {
               seconds += s;
               Normalize();
               return *this;
           }
        };
        ```
        
        Аналогично, объявим `operator +` для сложения объекта `Time` и целого числа секунд. В отличие от оператора `+=` он будет создавать новый объект `Time`, а не модифицировать текущий.
        
        ```C++
        class Time {
           // ...
         
        public:
           Time operator + (int s) const {
               return Time(hours, minutes, seconds + s);
           }
        };
        
        int main() {
            Time t(13, 30, 0);
            t += 40;  // теперь в t записано время 13:30:40
         
            Time t2 = t + 20;  // объект t не изменился, а в t2 записано 13:31:00
        }
        ```
        
        Вообще-то этот оператор `+` мы могли бы объявить и как внешнюю функцию. Если интерфейс класса это позволяет сделать, то такой способ более предпочтителен:
        
        ```C++
        Time operator + (const Time& t, int s) {  // обратите внимание: тут не может быть модификатора const, это внешняя функция
            return Time(t.GetHours(), t.GetMinutes(), t.GetSeconds() + s);
        }
        ```
        
        Более того, можно воспользоваться готовым оператором `+=`:
        
        ```C++
        // Принимаем t по значению, чтобы эту копию можно было изменить
        Time operator + (Time t, int s) {
            t += s;
            return t;
        }
        ```
        
        Было бы большой ошибкой возвращать из `operator +` значение по ссылке, как в `operator +=`. Действительно, в операторе `+` возвращается по значению новый объект, который был сконструирован локально. Ссылка на него сразу бы стала висячей.
        
    - Оператор вычитания
        
        Перегрузим теперь оператор вычитания. Он позволит вычитать одно время из другого и получать число секунд между этими временными метками. Но сначала добавим в класс полезную функцию `TotalSeconds`, которая вернёт число секунд с начала суток:
        
        ```C++
        class Time {
           // ...
         
        public:
            int TotalSeconds() const {
               return hours * 60 * 60 + minutes * 60 + seconds;
            }
        };
        ```
        
        Теперь можно определить `operator -` просто как внешнюю функцию:
        
        ```C++
        int operator - (const Time& t1, const Time& t2) {
            return t1.TotalSeconds() - t2.TotalSeconds();
        }
        ```
        
    - Операторы ввода-вывода
        
        Операторы `<<` и `>>` на самом деле применяются к целым числам и выполняют [побитовые сдвиги](https://en.cppreference.com/w/cpp/language/operator_arithmetic#Bitwise_shift_operators). Как мы знаем, в стандартной библиотеке они перегружены для форматированного потокового ввода и вывода. Покажем, как сделать это для своего класса.
        
        ```C++
        \#include <iostream>
         
        std::ostream& operator << (std::ostream& out, const Time& t) {
            out << t.GetHours() << ":" << t.GetMinutes() << ":" << t.GetSeconds();
            return out;
        }
         
        std::istream& operator >> (std::istream& in, Time& t) {
            int h, m, s;
            char dummy;
            // Считываем число и любой непробельный символ за ним
            in >> h >> dummy;
            in >> m >> dummy;
            in >> s >> dummy;
         
            // У нас нет другого способа изменить время через публичный интерфейс
            // кроме присваивания нового значения
            t = Time(h, m, s);
            return in;
        }
        ```
        
        Мы перегрузили два оператора `<<` и `>>`. Первым аргументом они получают по ссылке входной или выходной поток. Второй аргумент — переменная нашего класса. Для оператора `<<` она передаётся по константной ссылке, а для `>>` — просто по ссылке, так как будет изменяться. Оба оператора возвращают ссылку на поток, чтобы можно было создавать цепочки вида `std::cout << x << y << z`.
        
        Обратите внимание, что оба перегруженных оператора работают с абстрактными потоками `in` и `out`, а не с конкретными `std::cin` или `std::cout`. Это позволяет их применять к потокам, связанным с файлами или строками.
        
        Теперь можно читать и печатать время:
        
        ```C++
        int main() {
            Time t;
            // Считываем время в формате hh:mm:ss,
            // где на самом деле вместо двоеточия может быть любой разделитель
            std::cin >> t;
         
            t += 40;
            std::cout << t << "\n";  // печатаем время в формате hh:mm:ss
        }
        ```
        
- Готовый вариант
    
    ```C++
    \#include <iostream>
    
    
    class Time {
    private:
        int hours;
        int minutes;
        int seconds;
        void Normalize() {
            minutes += seconds / 60;
            hours += minutes / 60;
            hours = hours % 24;
            minutes = minutes % 60;
            seconds = seconds % 60;
        }
    public:
        // 1
        Time(int h, int m, int s) {
            hours = h;
            minutes = m;
            seconds = s;
            Normalize();
        }; // hh:mm:ss
    
        // 2
        Time(int s) : Time(0, 0, s) {
        };
        // 3
        Time() = default;
    
        int GetSeconds() const {
            return seconds;
        };
        int GetHours() const {
            return hours;
        };
        int GetMinutes() const {
            return minutes;
        };
    
        Time& operator += (int s) {
            seconds += s;
            Normalize();
            return *this;
        }
    
    };
    
    
    
    std::istream& operator >> (std::istream& in, Time& t) {
        int h, m, s;
        char dummy;
        in >> h >> dummy;
        in >> m >> dummy;
        in >> s >> dummy;
        t = Time(h, m, s);
        return in;
    }
    
    
    std::ostream& operator << (std::ostream& out, const Time& t) {
        if (t.GetHours() / 10 < 1) {
            out << 0 << t.GetHours() << ':';
        }
        else {
            out << t.GetHours() << ':';
        }
        //
        if (t.GetMinutes() / 10 < 1) {
            out << 0 << t.GetMinutes() << ':';
        }
        else {
            out << t.GetMinutes() << ':';
        }
        //
        if (t.GetSeconds() / 10 < 1) {
            out << 0 << t.GetSeconds();
        }
        else {
            out << t.GetSeconds();
        }
    
        return out;
    }
    
    
    Time operator + (const Time& t, int s) {
        return Time(t.GetHours(), t.GetMinutes(), t.GetSeconds() + s);
    }
    
    
    int operator - (const Time& t1, const Time& t2) {
        return t1.GetHours() * 60 * 60 +
            t1.GetMinutes() * 60 + t1.GetSeconds() -
            t2.GetHours() * 60 * 60 - t2.GetMinutes() * 60 -
            t2.GetSeconds();
    }
    
    
    
    int main() {
        Time t(14, 31, 65); // 14:32:05
        Time t2 = t + 225; // 14:35:50
        Time t3(13000); // 03:36:40
        std::cout << t2 - t3 << '\n';
        Time timeeee;
        std::cin >> timeeee;
        std::cout << timeeee;
    }
    ```