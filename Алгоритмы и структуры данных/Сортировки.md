# Простые квадратичные сортировки
### В общем

* основаны на простом последовательном сравнении элементов
* последовательно увеличивают отсортированную часть массива
* имеют временную сложность $O(n^2)$
## Сортировка выбором (selection sort)

* Последовательно выбирается __минимум__ в неотсортированной части
* Нет хорошего случая, всегда $O(n^2)$
![[184_9_b67b9a57f4_deb9de7372.gif]]
## Сортировка вставками (insertion sort)

* Последовательно элемент из неотсортированной части сравнивается с элементом из отсортированной(если для возрастания, то с конца) и если меньше(больше) вставляется (*на самом деле просто свапается*) в отсортированную часть 
* Худший случай $O(n^2)$ (отсортированный в обратном порядке)
* Лучший случай $O(n)$ (отсортированный в нужном порядке)

![insertion](/images/184_7_a71e9fe3fb_119defdcea.gif)
```c++
void InsertionSort(vector<int>& values) { 
	for (size_t i = 1; i < values.size(); ++i) { 
		int x = values[i]; 
		size_t j = i; 
		while (j > 0 && values[j - 1] > x) { 
			values[j] = values[j - 1]; 
			--j; 
		} 
		values[j] = x; 
	} 
}
```
## Сортировка пузырьком (bubble sort)

* Попарно сравниваются элементы и меняются местами
* Без каких либо модификаций - $O(n^2)$
* Если добавить флаг, то возможен лучший случай с $O(n)$

![bubble](/images/1_49e0bb0f63_63adb81133.gif)
```c++
void BubbleSort(vector<int>& values) {
	for (size_t idx_i = 0; idx_i + 1 < values.size(); ++idx_i) {
		for (size_t idx_j = 0; idx_j + 1 < values.size() - idx_i; ++idx_j) {
			if (values[idx_j + 1] < values[idx_j]) {
				swap(values[idx_j], values[idx_j + 1]); 
			} 
		} 
	} 
}
```

# Специальные сортировки
## Сортировка подсчетом (counting sort)

* Создается новый счетный массив, в котором пара $(index, value)$ это элемент и количество его повторений в массиве
* Сложность $O(n+m)$ где $m$ - range в котором находятся элементы
* Проблема в дополнительном знании и работе __только с целыми числами__
## Блочная сортировка (bucket sort)

* Числа раскладываются по блокам определенного диапазона, а после сортируются внутри каждого блока и выгружаются в общий массив
* Позволяет не сравнивать элементы в разных блоках, так как они однозначно больше или меньше друг друга
* В хорошем случае работает $O(n+m)$, где $m$ - количество корзин
* В плохом - $O(n^2)$

## Поразрядная сортировка (radix sort)

* Все числа сортируются по разряду. Числа вносятся в новый массив `[1-9]` по принципу того, какой цифре равен их текущий разряд
* Сложность $O(n*k)$ где $k$ - количество разрядов в максимальном числе
### Least Significant Digit (LSD)

* Начинается с малого разряда
* Получается привычный для чисел порядок
### Most Significant Digit (MSD)

* Начинается с большего разряда
* Получается сортировка для природы строк (1 10 11 2  3 4)
# Эффективные сортировки

## Сортировка слиянием (merge sort)

Используется принцип рекурсивного разделения исходного массива на более маленькие массивы, вплоть до массива размером 1, для которого решение является тривиальным
Ход решения:
* Массив рекуррентно разбивается на меньшие массивы, до размера 1
* Соседние массивы сливаются в один в нужном порядке (возрастание или убывание)
* Это продолжается до тех пор, пока все массивы в обратном порядке рекурсии не сольются в один
Свойства:
* Сложность: $O(n*log_2(n))$ 
* Стабильная
![merge](/images/184_13_2ce8dc5e4e_0721bebc5e.gif)
#### Galloping mode

В случае, если из массива A переноситься подряд несколько элементов, то увеличивается шаг проверки A и B, чтобы найти границу, до которой можно переносить элементы без сравнений. Это позволяет кратно увеличить скорость слияния
## Быстрая сортировка (quick sort)

Ход работы:
* Выбирается опорный элемент(pivot)
* Все элементы большие pivot переносятся в одну сторону, меньшие в другую
* Рекурсивно выполняется то же самое для двух частей по разные стороны pivot (выбирается новый pivot для каждого)
Свойства:
* Сложность $O(n*log_2(n))$ 
* Не стабильная


![quicksort](/images/184_11_3c7583c6cd_59878a71a8.gif)
### Разбиение Ломуто

* __Pivot__ выбирается, как самый правый элемент
* Цикл проходиться по массиву и элементы меньше __pivot__ переставляет в начало (по очереди на ___i___ место, начиная с нуля)
* После выполнения цикла сам pivot перемещается на ___i+1___ место

### Разбиение Хоара

* __Pivot__ берётся как первый элемент
* Два указателя проходят по массиву с разных сторон (___i___ с начала ___j___ с конца)
* ___i___ увеличивается пока элемент с таким индексом меньше или равен __pivot__
* ___j___ уменьшается пока элемент с таким индексом больше чем __pivot__
* Как только оба указателя зафиксировались их элементы меняются местами, для того чтобы ___i___ и ___j___ могли дальше идти по массиву.
* Когда ___i___ совпадает с ___j___ или больше него, __pivot__ меняется с последним ___i___ и возвращается указатель на него

## Timsort

**Идея:** реальные данные скорее всего уже содержат отсортированные под массивы, будем это использовать
1) Спец. алгоритмом разбиваем на подмассивы
2) Сортируем их сортировкой вставками
3) Соединяем модифицированной сортировкой слиянием
Каждый подмассив - $run$ упорядочен

Для начала следует определить минимальный $run$ - $minrun$ 
- Лучше всего брать в \[32,64\]
- Брать первые 6 бит длины массива и прибавить 1

Далее следует разбиение:
1) Берутся текущий и следующий элемент (они всегда будут в $run$)
2) Переходим к следующему
3) Пока порядок сохраняется добавляем элементы
4) Если порядок нарушился, но текущий $run < minrun$, то дополняем $run$ до минимального значения

Далее следует модифицированное или обычное слияние:
- [Galloping mode](#Galloping-mode)


