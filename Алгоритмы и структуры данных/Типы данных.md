# Связный список

```c
typedef struct node {
	int val;
	struct node * next;
} node_t;

node_t * __init__() {
	node_t * head = NULL;
	head = malloc(sizeof(node_t));
	if(node == NULL){
		return 0;
	}
	else return node;
}
```

Перебор связного списка:
```c
while(current!=NULL){
printf("%d",current->val);
current = current->next;
}
```

## Односвязный список

Хранит указатель на следующий элемент.
`1->2->3->NULL`
## Двусвязный список

Хранит указатель на предыдущий и следующий элемент.
`NULL<-1-><-2-><-3->NULL`
## Простые операции

|                      | Односвязный | Односвязный с tail | Двусвязный с tail |
| -------------------- | :---------: | :----------------: | :---------------: |
| **Взятие из начала** |   $O(1)$    |       $O(1)$       |      $O(1)$       |
| **Взятие из конца**  |   $O(n)$    |       $O(1)$       |      $O(1)$       |
| **Вставка в начало** |             |                    |                   |

## Плюсы и минусы

|                                                            Преимущества                                                             |                  Недостатки                  |
| :---------------------------------------------------------------------------------------------------------------------------------: | :------------------------------------------: |
|                                              Переполнение только если кончиться память                                              |     Дополнительная память для указателей     |
|                                          Простые и эффективные операции вставки и удаления                                          |    Нет эффективного произвольного доступа    |
| При работе с большими данными перемещение указателей проще чем копирование(не переносим данные, а обращаемся к одной ячейке данных) | Менее эффективные в использовании кэш-памяти |
# Стек

Тип данных структуры **Last In First Out**(LIFO), так что доступ получается только к последнему добавленному элементу
## Как статический массив
```c
typedef struct stack{
	int top;
	size_t capacity;
	int * arr;
} stack_t;

int is_empty(stack_t * st){
	if(st->top==-1) return 1;
	return 0;
}
int is_full(stack_t * st){
	if(top>=capacity) return 1;
	return 0;
}
```
## Как связный список
```c
typedef struct stack{
	node_t * head; // Хранит только указатель на последний(первый в списке) элемент
}
```

## Операции

|          | Сложность |
| -------- | --------- |
| Взятие   | $O(1)$    |
| Удаление | $O(1)$    |
| Вставка  | $O(1)$    |
# Очередь

Тип данных, работающий по типу **First In First Out**(FIFO)

```c
typedef struct Queue{
	node_t * front;
	node_t * rear;
} queue_t;
```
## Операции

- Взятие элемента из начала или из конца без удаления
- Вставка только в конец
- Удаление только начала
