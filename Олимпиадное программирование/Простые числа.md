## Рубрика удивительное рядом

__1 - не простое число__ 


## Проверка на простое


```c++
int is_simple(int n){
	for (int i = 2; i*i<=n;i++) {
		if(n%i == 0) return 0;
	}
	return 1;
}
```

## Алгоритм Эратосфена

Создаёт массив с N индексами, которые означают числа, а элемент под индексом 0 - если простое число, 1, если составное.

```c++
d[N]; // {0, 0, 0, ..., 0}
void ert(int n) {
	for(int i = 2; i<=n;i++){
		if (d[i] == 0){
			for(int j = i*2;j<=n;j+=i){
				d[j] = 1; // просто сохранит запись о том что число составное
			}
		}
	}
}
```

Можно модифицировать для полезной информации:
>`d[j] = 1;`:

```с++
d[j] = i; // сохранить наибольший простой делитель
d[j]++; // сохранить количество простых делителей 
```
Можно вообще сделать `d[j]` вектором и сохранять туда простые делители